prog: ^^__ @:Block=(statements) __ [@:ParseError=(+(./\n)=>"Invalid code")]$$

term: (
    Bool / Nil
    / Fail / Return / Skip / Stop / Use / TypeOf
    / Lambda / Cast
    / unaryOp
    / Global !(_`(,{) / Var !(_`(,{)
    / Percent / Measure / Float / Int
    / String / DSL
    / ListComprehension / List
    / TableComprehension / Table
    / Struct / FnCall
    / `(__extended-expr__`)
)
IndexedTerm:: (!`0-9 @value=(methodCall / IndexedTerm / term)
  @index=(`. FieldName / `[ __ required-extended-expr __ `] / @:ParseError=(`[ => "Unclosed bracket")))
maybe-index-term: methodCall / IndexedTerm / term
expr: Range / ButWith / Mod / AddSub / MulDiv / Pow / methodCall / IndexedTerm / term
extended-expr: TernaryOp / And / Or / Xor / comparison / splatFnCall / splatMethodCall / expr
unaryOp: Negative / Len / Not
Negative:: `- !`0-9,. @value=maybe-index-term
Len:: `# _ @value=maybe-index-term
Not:: \b"not"\b _ @value=(comparison / expr)
Mod:: @lhs=(AddSub / MulDiv / Pow / maybe-index-term) _ \b"mod"\b _ @rhs=(AddSub / MulDiv / Pow / maybe-index-term)
AddSub:: @lhs=(AddSub / MulDiv / Pow / maybe-index-term) _ @op=`+,- _ @rhs=(MulDiv / Pow / maybe-index-term)
MulDiv:: @lhs=(MulDiv / Pow / maybe-index-term) _ @op=`*,/ _ @rhs=(Pow / maybe-index-term)
Pow:: @base=maybe-index-term _ `^ _ @exponent=maybe-index-term
ButWith:: (@base=maybe-index-term _ `& _
  *@:ButWithAssign=((`. @field=FieldName / `[__@index=required-extended-expr__`])
     _`=_ @value=required-extended-expr) % (_`,,|_) [_`,])
And:: 2+(comparison / expr) % (_\b"and"\b_)
Or:: 2+(comparison / expr) % (_\b"or"\b_)
Xor:: @lhs=(comparison / expr) _\b"xor"\b_ @rhs=(Xor / comparison / expr)
Less:: @lhs=expr _ "<" _ @rhs=expr
LessEq:: @lhs=expr _ "<=" _ @rhs=expr
Greater:: @lhs=expr _ ">" _ @rhs=expr
GreaterEq:: @lhs=expr _ ">=" _ @rhs=expr
Equal:: @lhs=expr _ "==" _ @rhs=expr
NotEqual:: @lhs=expr _ "!=" _ @rhs=expr
comparison: Equal / NotEqual / LessEq / Less / GreaterEq / Greater
TernaryOp:: (@condition=(And/Or/Xor/comparison/expr) _ 
  `? _ @ifTrue=required-extended-expr _
  (`; / `: @:ParseError=(=>"Ternary operator uses semicolon (;) not colon (:)")) _ @ifFalse=required-extended-expr)
Bool:: \b("yes"/"no")\b
Nil:: \b"nil"\b
String:: (
  `" @curdent:\C $ \n @strdent:\C strdent @content=@..%(@:Newline=(\n strdent) / \n$ / Escape / Interp) (\n curdent `")
  / @:ParseError=(`"$ .. % \n $$ => "Failed to find closing quote with the right indentation")
  / `' @curdent:\C $ \n @strdent:\C strdent @content=@..%(@:Newline=(\n strdent) / \n$) (\n curdent `')
  / @:ParseError=(`'$ .. % \n $$ => "Failed to find closing quote with the right indentation")
  / `` @curdent:\C $ \n @strdent:\C strdent @content=@..%(@:Newline=(\n strdent) / \n$) (\n curdent ``)
  / @:ParseError=(``$ .. % \n $$ => "Failed to find closing backtick with the right indentation")
  / `" @content=@..%(Escape/Interp) `"
  / `` @content=@..%Interp ``
  / `' @content=@.. `'
  / @:ParseError=(`",'..$ => "Missing closing quote")
  )
DSL:: `% [@name=id] @string=(
  String
  / @:String=(`[ @content=@..%(Escape/Interp) `]) / @:ParseError=(`[..$ =>"Missing closing ]")
  / @:String=(`< @content=@..%(Escape/Interp) `>) / @:ParseError=(`<..$ =>"Missing closing >")
  / @:String=(`( @content=@..%Interp `)) / @:ParseError=(`(..$ =>"Missing closing )")
  / @:String=(`{ @content=@.. `}) / @:ParseError=(`{..$ =>"Missing closing }")
  / @:String=(`: _ @curdent:\C $ \n @strdent:\C strdent @content=@..%(@:Newline=(\n strdent) / \n$ / Escape / Interp) >(+\n !strdent . / $$$))
  / @:String=(`> _ @curdent:\C $ \n @strdent:\C strdent @content=@..%(@:Newline=(\n strdent) / \n$ / AtInterp) >(+\n !strdent . / $$$))
  / @:String=(`:,  _ @content=@..%(Escape/Interp) $)
  / @:String=(`> _ @content=@..%AtInterp $)
  / @:String=(@delim:. @curdent:\C $ \n @strdent:\C strdent @content=@..%(@:Newline=(\n strdent) / \n$ / Escape / Interp) (\n curdent delim))
  / @:String=(@delm:. @content=@..%(Escape/Interp) delim) / @:ParseError=(..$ =>"This string has no closing delimiter"))
List:: `[__*extended-expr %(__`,__) __ [`,__] `] [_`:_@type=type] / `[__`:__@type=@:ListType=(@itemtype=type)__`]
ListComprehension:: (`[ __
  @expression=extended-expr __ \b"for"\b __
  [@index=Var__`,__] @val=Var __ "in" __ @iterable=required-extended-expr __
  [(@control=(Skip/Stop) __ (PostfixConditional / @:ParseError=(..>`] =>"Expected to see a condition here")))
   / PostfixConditional] __`])
PostfixConditional: \b"if"\b _ @condition=required-extended-expr / \b"unless"\b_ @condition=@:Not=(@value=required-extended-expr)
Cast:: @expr=(methodCall / Measure / Float / Percent / Int / Global / Var / `(__extended-expr__`))_`:_@type=type
Interp:: `$ @value=(Var / `(__ required-extended-expr __`) / @:String=@content=`$)
AtInterp: @:Interp=(`@ @value=(Var / `(__ required-extended-expr __`) / @:String=@content=`@))
Escape:: `\ (`x 2 hex / `a,b,t,n,r,v / 3 `0-8 / .)
Float:: [`-,+] (`0-9 *`0-9,_ (`. !`. *`0-9,_ / >`e) / `. `0-9 *`0-9,_) [`e [`+,-] `0-9 *`0-9,_]
Measure:: @amount=(Float/Int) @units=MeasureType
MeasureType:: `< +@(@unit=id [`^ @power=([`-] +`0-9)]) % (`*,/) `>
Percent:: (`0-9 *`0-9,_ [`. *`0-9] / `. +`0-9) `%
Int:: "0x" +`0-9,a-f,A-F,_ / [`-,+] `0-9 *`0-9,_
Struct:: [@name=Var] _ `{ __ *@:StructField=([`. @name=FieldName __`=__] @value=required-extended-expr) % (__`,__) [__`,] __ `}
Table:: `{ __ (
  (`:__ @type=@:TableType=(@keyType=type __ `= __ @valueType=type))
  / (*@:TableEntry=((`[__@key=required-extended-expr__`] / @key=@:String=(@content=id)) __`= __ @value=required-extended-expr)%(__`,__) [__`,])
  ) __ `}
TableComprehension:: (`{ __
  @entry=@:TableEntry=(@key=required-extended-expr__`, __ @value=required-extended-expr) __ \b"for"\b __
  [@index=Var__`,__] @val=Var __ "in" __ @iterable=required-extended-expr __
  [(@control=(Skip/Stop) __ (PostfixConditional / @:ParseError=(..>`] =>"Expected to see a condition here")))
   / PostfixConditional] __`})
FnCall:: @fn=(FnCall / IndexedTerm / Global / Var / `(__required-extended-expr__`)) `( __ *extended-expr % (__`,__) __ [`,__] `) [_`:_@type=type]
methodCall: @:FnCall=((methodCall / IndexedTerm / term) _ `| _
  (@fn=(Global / Var / `(__required-extended-expr__`)) _
   [`( __ *expr % (__`,__) __ [`,__] `)] / @:ParseError=(=>"Not a valid method call")) [_`:_@type=type])
splatFnCall: @:FnCall=(@fn=(FnCall / IndexedTerm / Global / Var / `(__required-extended-expr__`)) +(` /\t) +extended-expr % +(` ,,/\t))
splatMethodCall: @:FnCall=((methodCall / IndexedTerm / term) _ `| _
  (@fn=(Global / Var / `(__required-extended-expr__`)) +(` /\t) +expr % +(` ,,/\t) / @:ParseError=(=>"Not a valid method call")))
Var:: id !~ keyword
FieldName:: id !~ keyword
Global:: `$ id
id: \b(\I *\i)
statements: @curdent:\C +(
    comment
  / @statement _ [comment] [@:ParseError=(+. => "Cannot parse this code")]
  / !$ @:ParseError=(@dent:\C ..$ *(\n dent (` /\t)..$) =>"Invalid statement")) % (nl curdent !(` /\t))
indentedBlock: @:Block=([_comment] nl curdent +(` /\t) statements)
statement: (
    Declaration / FnDecl / If / When / For / While / Repeat
  / TypeDeclaration / StructDeclaration / UnitDeclaration / EnumDeclaration
  / PostfixIf / PostfixFor / PostfixWhile
  / Return / Skip / Stop / Export / Use
  / line-statement
  ) _ [comment]
Skip:: \b"skip"\b [_ @target=(\b"for"\b / \b"while"\b / \b"repeat"\b / Var)]
Stop:: \b"stop"\b [_ @target=(\b"for"\b / \b"while"\b / \b"repeat"\b / Var)]
line-statement: (
    @:Pass=(\b"pass"\b _ [comment]) / Fail
  / Assignment / AddUpdate / SubUpdate / MulUpdate / DivUpdate / AndUpdate / OrUpdate / XorUpdate / ButWithUpdate / MethodCallUpdate
  / extended-expr) _ [comment]
Fail:: \b"fail"\b _ [@message=extended-expr]
Declaration:: @var=Var _`: _[@type=type_] `= _ @value=required-extended-expr
TypeDeclaration:: \b"deftype"\b _ @name=@:NamedType=(id) _ `: _ @derivesFrom=(type / @:ParseError=(..$ =>"Not a valid type"))
UnitDeclaration:: \b"unit"\b _ @name=@:NamedType=(id) _ `= _ @measure=Measure
StructDeclaration:: \b"struct"\b _ (StructType / @:ParseError=((braces /..$) =>"Not a valid struct declaration"))
EnumDeclaration:: \b"enum"\b _ @name=Var _ (`{__+(@Var) % (__`,__) __ [`,__] `} / @:ParseError=((braces /..$) =>"Not a valid enum declaration"))
FnDecl:: @curdent:\C "def"\b _ (@name=Var _
  `( __ @args=@(*((@:FnArg=(@arg=Var_`:_@type=type) / @:ParseError=(Var =>"This argument doesn't have a type")))%(__`,__))__[`,__]`)_
  (`: / @:ParseError=(=>"Expected a colon here"))_[@return=type]_ [comment]
  ((`= _ @body=(@:Block=(
      [_comment] nl curdent +(` /\t) @curdent:\C @:Return=(@value=required-extended-expr)
      / @:Return=(@value=required-extended-expr) _ [comment])))
   / @body=maybeIndentedBlock))
Lambda:: (@curdent:\C
  @args=@[`(__*@:FnArg=(@arg=Var__`:__@type=type)%(__`,__)__[`,__]`)]
  [_`:_@return=type]_
  (("=>" _ [comment] __ @body=@:Block=(
      [_comment] nl curdent +(` /\t) @curdent:\C @:Return=(@value=required-extended-expr)
      / @:Return=(@value=required-extended-expr)_ [comment]))
   / ("->"_ [comment] (@body=maybeIndentedBlock / @:ParseError=(..$ =>"Invalid lambda body"))))
)
Assignment:: @lhs=(IndexedTerm / Var) _ `= _ @rhs=required-extended-expr
AddUpdate:: @lhs=Var _ "+=" _ @rhs=required-extended-expr
SubUpdate:: @lhs=Var _ "-=" _ @rhs=required-extended-expr
MulUpdate:: @lhs=Var _ "*=" _ @rhs=required-extended-expr
DivUpdate:: @lhs=Var _ "/=" _ @rhs=required-extended-expr
AndUpdate:: @lhs=Var _ "and=" _ @rhs=required-extended-expr
OrUpdate:: @lhs=Var _ "or=" _ @rhs=required-extended-expr
XorUpdate:: @lhs=Var _ "xor=" _ @rhs=required-extended-expr
MethodCallUpdate:: (Var _ "|=" _
  (@fn=(Global / Var / `(__required-extended-expr__`)) _
   [`( __ *expr % (__`,__) __ [`,__] `) / +expr % +(` ,,/\t)] / @:ParseError=(=>"Not a valid method call")) [_`:_@type=type])
ButWithUpdate:: (@base=Var _ "&=" _
  *@:ButWithField=((`. @field=FieldName / `[__@index=required-extended-expr__`]) _`=_ @value=required-extended-expr) % (_`,,|_) [_`,])
required-extended-expr: extended-expr / @:ParseError=(..$ =>"Invalid expression")
type: @:OptionalType=(@nonnil=nonoptional-type `?) / nonoptional-type
nonoptional-type: (
    @:TableType=(`{__ @keyType=type __`=__ @valueType=type __`})
  / MeasureType
  / StructType
  / @:DerivedType=(@name=id ":" @derivesFrom=(type / @:ParseError=(..$ =>"Not a valid type")))
  / @:NamedType=(id)
  / @:ListType=(`[@itemtype=type`])
  / @:FnType=(`(__ @args=@(*type % (__`,__)) __ `) _ "=>" __ @return=type)
)
StructType:: @name=[id] _ `{__ @members=@(*@:StructField=([@name=FieldName_`:]_@type=type) % ((__`,__/__)~(`,/\n))) [__`,] __`}
If:: \b"if"\b @curdent:\C _ (
    @:Clause=(@condition=required-extended-expr [_comment] @body=indentedBlock)
    *@:Clause=(nl curdent \b"elseif"\b _ @condition=required-extended-expr [_comment] @body=indentedBlock)
    [nl curdent \b"else"\b [_comment] @elseBody=maybeIndentedBlock]
)
PostfixIf: @:If=(@:Clause=(@body=@:Block=@(Return / Skip / Stop / line-statement) _ PostfixConditional _ [comment]))
PostfixFor: @:For=(@body=@:Block=@(line-statement) _
  \b"for"\b _ [@index=Var_`,_] @val=Var _ "in" _ @iterable=required-extended-expr _ [comment])
PostfixWhile: @:While=(@body=@:Block=@(line-statement) _
  \b"while"\b _ @condition=extended-expr _ [comment])
When:: ( \b"when"\b @curdent:\C _
  @what=required-extended-expr _ [[comment] nl curdent]
  +@:Clause=("is"\b _ @cases=@+required-extended-expr%(_`,_) _ [comment] @body=indentedBlock)%(nl curdent)
  [nl curdent "else" _ [comment] @elseBody=maybeIndentedBlock]
)
For:: (
  \b"for"\b @curdent:\C _ [@index=Var_`,_] @val=Var _ "in" _ @iterable=required-extended-expr _ [comment]
  @body=indentedBlock
  [between]
)
While:: (
  \b"while"\b @curdent:\C _ @condition=extended-expr _ [comment]
  @body=indentedBlock
  [between]
)
Repeat:: \b"repeat"\b @curdent:\C _ [comment] @body=maybeIndentedBlock [between]
maybeIndentedBlock: indentedBlock / @:Block=@(_line-statement_)
between: nl curdent \b"between"\b _ [comment] @between=(maybeIndentedBlock / @:ParseError=(..$ => "Invalid 'between' body"))
Return:: \b"return"\b _ [@value=extended-expr]
Use:: \b"use"\b _ `" @name=.. `" [_\b"or"\b_ @orElse=(Fail/Return/Skip/Stop)]
Export:: \b"export"\b _ +Var %(_`,__)
TypeOf:: \b"typeof"\b _ @expression=(expr)
Range:: (
  @first=maybe-index-term [`,@next=maybe-index-term] ".." [@last=maybe-index-term] # 0,2..4 x..y 1..
  / ".." [@last=maybe-index-term]) # ..5 ..
comment: "//" *.

# Keep keywords reverse-alphabetically sorted so you don't get spurious prefix matches (e.g. "no" instead of "not")
keyword: \b("yes"/"xor"/"with"/"while"/"when"/"use"/"unless"/"unit"/"typeof"/"stop"/"skip"/"return"/"repeat"/"pass"/"or"
  /"not"/"no"/"nil"/"mod"/"is"/"if"/"for"/"fail"/"export"/"elseif"/"else"/"deftype"/"between"/"as"/"and")\b
hex: `0-9,a-f,A-F
nl: +\n % (*(` /\t) [comment])
__: *(` /\t/\n/\r/comment)
_:  *(` /\t)

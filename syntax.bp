prog: ^^__Block__ [ParseError:: +(./\n) @message=(""=>"Invalid code")]$$

term: (
    Bool / Nil / String / Float / Int / unaryOp / Global !(_`(,{) / Var !(_`(,{) / Struct / FnCall / Lambda / List / `(__extended-expr__`)
)
IndexedTerm:: !`0-9 (MethodCall / IndexedTerm / term) (`. FieldName / `[ __ required-extended-expr __ `] / (ParseError:: `[ @message=(=> "Unclosed bracket")))
maybe-index-term: MethodCall / IndexedTerm / term
expr: Range / Append / Mod / Add / Sub / Mul / Div / Pow / MethodCall / IndexedTerm / term
extended-expr: TernaryOp / And / Or / Xor / comparison / expr
unaryOp: Negative / Len / Not
Negative:: `- !`0-9,. maybe-index-term
Len:: `# maybe-index-term
Not:: \b"not"\b _ (comparison / expr)
Mod:: (Add / Sub / Mul / Div / Pow / maybe-index-term) _ \b"mod"\b _ (Add / Sub / Mul / Div / Pow / maybe-index-term)
Add:: (Add / Sub / Mul / Div / Pow / maybe-index-term) _ `+ _ (Mul / Div / Pow / maybe-index-term)
Sub:: (Add / Sub / Mul / Div / Pow / maybe-index-term) _ `- _ (Mul / Div / Pow / maybe-index-term)
Mul:: (Mul / Div / Pow / maybe-index-term) _ `* _ (Pow / maybe-index-term)
Div:: (Mul / Div / Pow / maybe-index-term) _ `/ _ (Pow / maybe-index-term)
Pow:: @base=maybe-index-term _ `^ _ @exponent=maybe-index-term
Append:: (Append / maybe-index-term) _ `@ _ (maybe-index-term / (ParseError:: @message=(=>"Expected a value to append here")))
And:: 2+(comparison / expr) % (__\b"and"\b__)
Or:: 2+(comparison / expr) % (__\b"or"\b__)
Xor:: 2+(comparison / expr) % (__\b"xor"\b__)
Less:: expr _ "<" _ expr
LessEq:: expr _ "<=" _ expr
Greater:: expr _ ">" _ expr
GreaterEq:: expr _ ">=" _ expr
Equal:: expr _ "==" _ expr
NotEqual:: expr _ "!=" _ expr
comparison: Equal / NotEqual / LessEq / Less / GreaterEq / Greater
TernaryOp:: @condition=(And/Or/Xor/comparison/expr) _ `? _ @ifTrue=required-extended-expr _ `; _ @ifFalse=required-extended-expr
Bool:: \b("yes"/"no")\b
Nil:: \b"nil"\b
String:: (
  '"""' @curdent=\C $ \n @strdent=\C strdent @content=..%(@(Newline::\n strdent) / \n$ / @(Escape/Interp)) (\n curdent '"""')
  / (ParseError:: '"""' .. % \n $$ @message=(=> "Failed to find closing triple quote with the right indentation"))
  / `" @content=..%(@(Escape/Interp)) `"
  / (ParseError:: `"..$ @message=(=> "Missing closing quote")))
List:: `[__*extended-expr %(__`,__) __ [`,__] `] [_`:_@type=type] / `[__`:__@type=@(ListType::type)__`]
Interp: `$ (Var/`(__ extended-expr __`))
Escape:: `\ (`x 2 hex / `a,b,t,n,r,v / 3 `0-8 / .)
Float:: [`-,+] (`0-9 *`0-9,_ `. !`. *`0-9 / `. +`0-9)
Int:: [`-,+] `0-9 *`0-9,_
Struct:: [@name=Var] _ `{ __ *@([@name=FieldName __`=__] @value=required-extended-expr) % (__`,__) [__`,] __ `}
FnCall:: @fn=(FnCall / Global / Var / `(__expr__`)) `( __ *expr % (__`,__) __ [`,__] `) [_`:_@type=type]
MethodCall:: !`0-9 (MethodCall / IndexedTerm / term) _ `| _ (@fn=Var _ [`( __ *expr % (__`,__) __ [`,__] `)] / (ParseError:: => "Not a valid method call")) [_`:_@type=type]
Var:: id !~ (^^keyword$$)
FieldName:: id !~ (^^keyword$$)
Global:: `$ id
TypeVar:: id !~ (^^keyword$$)
id: \b(\I *\i)
Block:: @curdent=\C +(
    comment
  / statement
  / !$ (ParseError:: @dent=\C ..$ *(\n dent (` /\t)..$) @message=(=>"Invalid statement"))) % (nl curdent !(` /\t))
statement: (
    Declaration / FnDecl / If / When / For / While / Repeat / TypeDeclaration
  / (If::PostfixIf) / (For::PostfixFor) / (While::PostfixWhile)
  / Return / Skip / Stop
  / line-statement
  ) _ [comment]
Skip:: \b"skip"\b [_ @target=(\b"for"\b / \b"while"\b / \b"repeat"\b / Var)]
Stop:: \b"stop"\b [_ @target=(\b"for"\b / \b"while"\b / \b"repeat"\b / Var)]
line-statement: (
    (Pass:: "pass" _ [comment])
  / Assignment / AddUpdate / SubUpdate / MulUpdate / DivUpdate / AndUpdate / OrUpdate / XorUpdate / AppendUpdate
  / FnCall) _ [comment]
Declaration:: @var=Var _`: _[@type=type_] `= _ @value=required-extended-expr
TypeDeclaration:: @(NamedType::id) _ ":::" _ (type / (ParseError:: ..$ @message=(=>"Not a valid type")))
FnDecl:: @curdent=\C "def"\b _ (@name=Var _
  `( __ @args=*@((@arg=Var_`:_@type=type) / (ParseError:: Var @message=(=>"This argument doesn't have a type")))%(__`,__)__[`,__]`)_`:_[@return=type]_ [comment]
  @body=(`= _ extended-expr / nl curdent +(` /\t) Block))
Lambda:: (@curdent=\C
  `(__@args=*@(@arg=Var__`:__@type=type)%(__`,__)__[`,__]`)
  [_`:_@return=type]_"->"_ [comment]
  (@body=funcBody / (ParseError:: @message=(..$ =>"Invalid lambda body")))
)
funcBody: extended-expr / nl curdent +(` /\t) Block
Assignment:: (IndexedTerm/Var) _ `= _ required-extended-expr
AddUpdate:: Var _ "+=" _ required-extended-expr
SubUpdate:: Var _ "-=" _ required-extended-expr
MulUpdate:: Var _ "*=" _ required-extended-expr
DivUpdate:: Var _ "/=" _ required-extended-expr
AndUpdate:: Var _ "and=" _ required-extended-expr
OrUpdate:: Var _ "or=" _ required-extended-expr
XorUpdate:: Var _ "xor=" _ required-extended-expr
AppendUpdate:: Var _ "@=" _ required-extended-expr
required-extended-expr: extended-expr / (ParseError:: ..$ @message=(=>"Invalid expression"))
type: (
    # (VariantType:: 2+ type%`|)
    (StructType:: @name=Var `{__ *@(@name=FieldName_`:_@type=type) % (__`,__) [__`,] __`})
  / (NamedType::Var)
  / TypeVar
  / (ListType::`[type`])
  #/ (OptionalType:: `? type)
  / (FnType:: `(__ @args=(*type % (__`,__)) __ `) _ "->" __ @return=type)
)
If:: \b"if"\b @curdent=\C _ (
    @(@condition=required-extended-expr [comment] nl curdent +(` /\t) @body=Block)
    *@(nl curdent \b"elseif"\b _ @condition=required-extended-expr [comment] nl curdent +(` /\t) @body=Block)
    [nl curdent \b"else"\b [comment] @elseBody=maybeInlineBlock]
)
PostfixIf: (@(@body=(Block:: @(Return / Skip / Stop / line-statement)) _
  (\b"if"\b _ @condition=required-extended-expr
  / \b"unless"\b_ @condition=(Not::required-extended-expr)) _ [comment]))
PostfixFor: (@body=(Block:: @line-statement) _
  \b"for"\b _ [@index=Var_`,_] @var=Var _ "in" _ @iterable=required-extended-expr _ [comment])
PostfixWhile: (@body=(Block:: @line-statement) _
  \b"while"\b _ @condition=extended-expr _ [comment])
When:: ( \b"when"\b @curdent=\C _
  @what=required-extended-expr _ [[comment] nl curdent]
  @branches=+@("is"\b _ @cases=+required-extended-expr%(_`,_) _ [comment] nl curdent +(` /\t) @body=Block)%(nl curdent)
  [nl curdent "else" _ [comment] @elseBody=maybeInlineBlock]
)
For:: (
  \b"for"\b @curdent=\C _ [@index=Var_`,_] @var=Var _ "in" _ @iterable=required-extended-expr _ [comment]
  nl curdent +(` /\t) @body=Block
  [between]
)
While:: (
  \b"while"\b @curdent=\C _ @condition=extended-expr _ [comment]
  nl curdent +(` /\t) @body=Block
  [between]
)
Repeat:: \b"repeat"\b @curdent=\C _ [comment] @body=maybeInlineBlock [between]
maybeInlineBlock: nl curdent +(` /\t) Block / @(Block:: line-statement)
between: nl curdent \b"between"\b _ [comment] @between=(maybeInlineBlock / (ParseError:: ..$ => "Invalid 'between' body"))
Return:: \b"return"\b _ [extended-expr]
Range:: (
  @first=maybe-index-term [`,@next=maybe-index-term] ".." [@last=maybe-index-term] # 0,2..4 x..y 1..
  / ".." [@last=maybe-index-term]) # ..5 ..
comment: "//" *.

keyword: "nil"/"yes"/"no"/"for"/"while"/"between"/"if"/"elseif"/"else"/"with"/"and"/"or"/"xor"/"pass"/"not"/"skip"/"stop"/"unless"/"repeat"
hex: `0-9,a-f,A-F
nl: +\n % (*(` /\t) [comment])
__: *(` /\t/\n/\r/comment)
_:  *(` /\t)

prog: ^^__ @:Block=(statements) __ [@:ParseError=(+(./\n)=>"Invalid code")]$$

term: (
    Bool / Nil / String / DSL / Float / Int / Fail / Return / Skip / Stop / unaryOp
    / Global !(_`(,{) / Var !(_`(,{) / Struct / FnCall / Lambda / ListComprehension / List
    / Cast / `(__extended-expr__`)
)
IndexedTerm:: (!`0-9 @value=(methodCall / IndexedTerm / term)
  @index=(`. FieldName / `[ __ required-extended-expr __ `] / @:ParseError=(`[ => "Unclosed bracket")))
maybe-index-term: methodCall / IndexedTerm / term
expr: Range / ButWith / Mod / Add / Sub / Mul / Div / Pow / methodCall / IndexedTerm / term
extended-expr: TernaryOp / And / Or / Xor / comparison / expr
unaryOp: Negative / Len / Not
Negative:: `- !`0-9,. @value=maybe-index-term
Len:: `# @value=maybe-index-term
Not:: \b"not"\b _ @value=(comparison / expr)
Mod:: @lhs=(Add / Sub / Mul / Div / Pow / maybe-index-term) _ \b"mod"\b _ @rhs=(Add / Sub / Mul / Div / Pow / maybe-index-term)
Add:: @lhs=(Add / Sub / Mul / Div / Pow / maybe-index-term) _ `+ _ @rhs=(Mul / Div / Pow / maybe-index-term)
Sub:: @lhs=(Add / Sub / Mul / Div / Pow / maybe-index-term) _ `- _ @rhs=(Mul / Div / Pow / maybe-index-term)
Mul:: @lhs=(Mul / Div / Pow / maybe-index-term) _ `* _ @rhs=(Pow / maybe-index-term)
Div:: @lhs=(Mul / Div / Pow / maybe-index-term) _ `/ _ @rhs=(Pow / maybe-index-term)
Pow:: @base=maybe-index-term _ `^ _ @exponent=maybe-index-term
ButWith:: (@base=maybe-index-term _ `& _
  *@:ButWithAssign=((`. @field=FieldName / `[__@index=required-extended-expr__`])
     _`=_ @value=required-extended-expr) % (_`,,|_) [_`,])
And:: 2+(comparison / expr) % (_\b"and"\b_)
Or:: 2+(comparison / expr) % (_\b"or"\b_)
Xor:: @lhs=(comparison / expr) _\b"xor"\b_ @rhs=(Xor / comparison / expr)
Less:: @lhs=expr _ "<" _ @rhs=expr
LessEq:: @lhs=expr _ "<=" _ @rhs=expr
Greater:: @lhs=expr _ ">" _ @rhs=expr
GreaterEq:: @lhs=expr _ ">=" _ @rhs=expr
Equal:: @lhs=expr _ "==" _ @rhs=expr
NotEqual:: @lhs=expr _ "!=" _ @rhs=expr
comparison: Equal / NotEqual / LessEq / Less / GreaterEq / Greater
TernaryOp:: (@condition=(And/Or/Xor/comparison/expr) _ 
  `? _ @ifTrue=required-extended-expr _
  (`; / `: @:ParseError=(=>"Ternary operator uses semicolon (;) not colon (:)")) _ @ifFalse=required-extended-expr)
Bool:: \b("yes"/"no")\b
Nil:: \b"nil"\b
String:: (
  '"""' @curdent:\C $ \n @strdent:\C strdent @content=@..%(@:Newline=(\n strdent) / \n$ / Escape / Interp) (\n curdent '"""')
  / @:ParseError=('"""' .. % \n $$ => "Failed to find closing triple quote with the right indentation")
  / "'''" @curdent:\C $ \n @strdent:\C strdent @content=@..%(@:Newline=(\n strdent) / \n$) (\n curdent '"""')
  / @:ParseError=("'''" .. % \n $$ => "Failed to find closing triple quote with the right indentation")
  / `" @content=@..%(Escape/Interp) `"
  / `' @content=@.. `'
  / @:ParseError=(`",'..$ => "Missing closing quote")
  )
DSL:: `% @name=id @string=(
  String
  / @:String=(`[ @content=@..%(Escape/Interp) `]) / @:ParseError=(`[..$ =>"Missing closing ]")
  / @:String=(`{ @content=@.. `}) / @:ParseError=(`{..$ =>"Missing closing }")
  / @:String=(@delm:`|,/,;,, @content=@..%(Escape/Interp) delim) / @:ParseError=(`|,/,;,,..$ =>"This string has no closing delimiter"))
List:: `[__*extended-expr %(__`,__) __ [`,__] `] [_`:_@type=type] / `[__`:__@type=@:ListType=(@itemtype=type)__`]
ListComprehension:: (`[ __
  @expression=extended-expr __ \b"for"\b __
  [@index=Var_`,_] @var=Var __ "in" __ @iterable=required-extended-expr __
  [(@control=(Skip/Stop) __ (PostfixConditional / @:ParseError=(..>`] =>"Expected to see a condition here")))
   / PostfixConditional] __`])
PostfixConditional: \b"if"\b _ @condition=required-extended-expr / \b"unless"\b_ @condition=@:Not=(@value=required-extended-expr)
Cast:: `(__@expr=extended-expr__`)_`:_@type=type
Interp:: `$ @value=(Var / `(__ required-extended-expr __`))
Escape:: `\ (`x 2 hex / `a,b,t,n,r,v / 3 `0-8 / .)
Float:: [`-,+] (`0-9 *`0-9,_ `. !`. *`0-9 / `. +`0-9)
Int:: [`-,+] `0-9 *`0-9,_
Struct:: [@name=Var] _ `{ __ *@:StructField=([@name=FieldName __`=__] @value=required-extended-expr) % (__`,__) [__`,] __ `}
FnCall:: @fn=(FnCall / Global / Var / `(__required-extended-expr__`)) `( __ *extended-expr % (__`,__) __ [`,__] `) [_`:_@type=type]
methodCall: @:FnCall=((methodCall / IndexedTerm / term) _ `| _
  (@fn=(Global / Var / `(__required-extended-expr__`)) _
   [`( __ *expr % (__`,__) __ [`,__] `)] / @:ParseError=(=>"Not a valid method call")) [_`:_@type=type])
Var:: id !~ (^^keyword$$)
FieldName:: id !~ (^^keyword$$)
Global:: `$ id
id: \b(\I *\i)
statements: @curdent:\C +(
    comment
  / @statement _ [comment] [@:ParseError=(+. => "Cannot parse this code")]
  / !$ @:ParseError=(@dent:\C ..$ *(\n dent (` /\t)..$) =>"Invalid statement")) % (nl curdent !(` /\t))
indentedBlock: @:Block=([comment] nl curdent +(` /\t) statements)
statement: (
    Declaration / FnDecl / If / When / For / While / Repeat / TypeDeclaration
  / PostfixIf / PostfixFor / PostfixWhile
  / Return / Skip / Stop
  / line-statement
  ) _ [comment]
Skip:: \b"skip"\b [_ @target=(\b"for"\b / \b"while"\b / \b"repeat"\b / Var)]
Stop:: \b"stop"\b [_ @target=(\b"for"\b / \b"while"\b / \b"repeat"\b / Var)]
line-statement: (
    @:Pass=(\b"pass"\b _ [comment]) / Fail
  / Assignment / AddUpdate / SubUpdate / MulUpdate / DivUpdate / AndUpdate / OrUpdate / XorUpdate / ButWithUpdate / MethodCallUpdate
  / FnCall / methodCall) _ [comment]
Fail:: \b"fail"\b _ [@message=extended-expr]
Declaration:: @var=Var _`: _[@type=type_] `= _ @value=required-extended-expr
TypeDeclaration:: @name=@:NamedType=(id) _ ":::" _ @alias=(type / @:ParseError=(..$ =>"Not a valid type"))
FnDecl:: @curdent:\C "def"\b _ (@name=Var _
  `( __ @args=@(*((@:FnArg=(@arg=Var_`:_@type=type) / @:ParseError=(Var =>"This argument doesn't have a type")))%(__`,__))__[`,__]`)_
  (`: / @:ParseError=(=>"Expected a colon here"))_[@return=type]_ [comment]
  ((`= _ @body=(@:Block=(
      [comment] nl curdent +(` /\t) @curdent:\C @:Return=(@value=required-extended-expr)
      / @:Return=(@value=required-extended-expr) _ [comment])))
   / @body=maybeIndentedBlock))
Lambda:: (@curdent:\C
  @args=@[`(__*@:FnArg=(@arg=Var__`:__@type=type)%(__`,__)__[`,__]`)]
  [_`:_@return=type]_
  (("=>" _ [comment] __ @body=@:Block=(
      [comment] nl curdent +(` /\t) @curdent:\C @:Return=(@value=required-extended-expr)
      / @:Return=(@value=required-extended-expr)_ [comment]))
   / ("->"_ [comment] (@body=maybeIndentedBlock / @:ParseError=(..$ =>"Invalid lambda body"))))
)
Assignment:: @lhs=Var _ `= _ @rhs=required-extended-expr
AddUpdate:: @lhs=Var _ "+=" _ @rhs=required-extended-expr
SubUpdate:: @lhs=Var _ "-=" _ @rhs=required-extended-expr
MulUpdate:: @lhs=Var _ "*=" _ @rhs=required-extended-expr
DivUpdate:: @lhs=Var _ "/=" _ @rhs=required-extended-expr
AndUpdate:: @lhs=Var _ "and=" _ @rhs=required-extended-expr
OrUpdate:: @lhs=Var _ "or=" _ @rhs=required-extended-expr
XorUpdate:: @lhs=Var _ "xor=" _ @rhs=required-extended-expr
MethodCallUpdate:: (Var _ "|=" _
  (@fn=(Global / Var / `(__required-extended-expr__`)) _
   [`( __ *expr % (__`,__) __ [`,__] `)] / @:ParseError=(=>"Not a valid method call")) [_`:_@type=type])
ButWithUpdate:: (@base=Var _ "&=" _
  *@:ButWithField=((`. @field=FieldName / `[__@index=required-extended-expr__`]) _`=_ @value=required-extended-expr) % (_`,,|_) [_`,])
required-extended-expr: extended-expr / @:ParseError=(..$ =>"Invalid expression")
type: @:OptionalType=(@nonnil=nonoptional-type `?) / nonoptional-type
nonoptional-type: (
    @:StructType=(@name=id `{__ @members=@(*@:StructField=(@name=FieldName_`:_@type=type) % (__`,__)) [__`,] __`})
  / @:DerivedType=(@name=id ":" @derivesFrom=(type / @:ParseError=(..$ =>"Not a valid type")))
  / @:NamedType=(id)
  / @:ListType=(`[@itemtype=type`])
  / @:FnType=(`(__ @args=@(*type % (__`,__)) __ `) _ "=>" __ @return=type)
)
If:: \b"if"\b @curdent:\C _ (
    @:Clause=(@condition=required-extended-expr [comment] @body=indentedBlock)
    *@:Clause=(nl curdent \b"elseif"\b _ @condition=required-extended-expr [comment] @body=indentedBlock)
    [nl curdent \b"else"\b [comment] @elseBody=maybeIndentedBlock]
)
PostfixIf: @:If=(@:Clause=(@body=@:Block=@(Return / Skip / Stop / line-statement) _ PostfixConditional _ [comment]))
PostfixFor: @:For=(@body=@:Block=@(line-statement) _
  \b"for"\b _ [@index=Var_`,_] @var=Var _ "in" _ @iterable=required-extended-expr _ [comment])
PostfixWhile: @:While=(@body=@:Block=@(line-statement) _
  \b"while"\b _ @condition=extended-expr _ [comment])
When:: ( \b"when"\b @curdent:\C _
  @what=required-extended-expr _ [[comment] nl curdent]
  +@:Clause=("is"\b _ @cases=@+required-extended-expr%(_`,_) _ [comment] @body=indentedBlock)%(nl curdent)
  [nl curdent "else" _ [comment] @elseBody=maybeIndentedBlock]
)
For:: (
  \b"for"\b @curdent:\C _ [@index=Var_`,_] @var=Var _ "in" _ @iterable=required-extended-expr _ [comment]
  @body=indentedBlock
  [between]
)
While:: (
  \b"while"\b @curdent:\C _ @condition=extended-expr _ [comment]
  @body=indentedBlock
  [between]
)
Repeat:: \b"repeat"\b @curdent:\C _ [comment] @body=maybeIndentedBlock [between]
maybeIndentedBlock: indentedBlock / @:Block=@(_line-statement_)
between: nl curdent \b"between"\b _ [comment] @between=(maybeIndentedBlock / @:ParseError=(..$ => "Invalid 'between' body"))
Return:: \b"return"\b _ [@value=extended-expr]
Range:: (
  @first=maybe-index-term [`,@next=maybe-index-term] ".." [@last=maybe-index-term] # 0,2..4 x..y 1..
  / ".." [@last=maybe-index-term]) # ..5 ..
comment: "//" *.

keyword: ("nil"/"yes"/"no"/"for"/"while"/"between"/"if"/"elseif"/"else"/"with"/"and"/"or"/"xor"/"pass"/"not"
  /"skip"/"stop"/"unless"/"repeat"/"as"/"fail"/"return")
hex: `0-9,a-f,A-F
nl: +\n % (*(` /\t) [comment])
__: *(` /\t/\n/\r/comment)
_:  *(` /\t)
